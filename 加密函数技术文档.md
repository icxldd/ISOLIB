# 文件加密系统技术文档

## 文档信息
- **文档版本**: 1.0
- **创建日期**: 2024年
- **适用范围**: ISOLib加密库
- **技术栈**: C++ Windows API

---

## 目录
1. [系统概述](#系统概述)
2. [双密钥流式加密系统](#双密钥流式加密系统)
3. [自包含式加密系统](#自包含式加密系统)
4. [技术实现细节](#技术实现细节)
5. [API接口说明](#api接口说明)
6. [使用示例](#使用示例)
7. [安全特性](#安全特性)
8. [性能优化](#性能优化)
9. [错误处理](#错误处理)
10. [最佳实践](#最佳实践)

---

## 系统概述

本加密系统提供了两种主要的文件加密方案：

### 1. 双密钥流式加密系统 (StreamEncryptFile/StreamDecryptFile)
- **特点**: 需要预先设置私钥，加密时传入公钥
- **适用场景**: 需要长期使用固定私钥的场景
- **优势**: 私钥可重复使用，适合批量加密

### 2. 自包含式加密系统 (SelfContainedEncryptFile/SelfContainedDecryptFile)
- **特点**: 自动生成2048位私钥并嵌入到加密文件中
- **适用场景**: 单次加密，无需管理私钥的场景
- **优势**: 使用简单，私钥自动管理

---

## 双密钥流式加密系统

### 核心函数

#### StreamEncryptFile
```cpp
PDUDLL_API int StreamEncryptFile(
    const char* filePath,           // 输入文件路径
    const char* outputPath,         // 输出文件路径
    const unsigned char* publicKey, // 公钥
    ProgressCallback progressCallback = nullptr // 进度回调函数
);
```

#### StreamDecryptFile
```cpp
PDUDLL_API int StreamDecryptFile(
    const char* filePath,           // 输入加密文件路径
    const char* outputPath,         // 输出文件路径
    const unsigned char* publicKey, // 公钥
    ProgressCallback progressCallback = nullptr // 进度回调函数
);
```

### 使用流程

#### 1. 初始化私钥
```cpp
// 设置私钥（只需执行一次）
int result = InitStreamFile("your_private_key_here");
if (result != 0) {
    // 处理错误
}
```

#### 2. 加密文件
```cpp
// 加密文件
const char* publicKey = "your_public_key_here";
result = StreamEncryptFile("input.txt", "output.enc", (unsigned char*)publicKey, progressCallback);
```

#### 3. 解密文件
```cpp
// 解密文件（需要相同的私钥和公钥）
result = StreamDecryptFile("output.enc", "decrypted.txt", (unsigned char*)publicKey, progressCallback);
```

### 文件格式结构

```
[魔数头: "ENCV1.0"] (7字节)
[组合密钥长度] (4字节)
[公钥哈希值] (4字节)
[加密数据] (变长)
[CRC32校验和] (4字节)
```

---

## 自包含式加密系统

### 核心函数

#### SelfContainedEncryptFile
```cpp
PDUDLL_API int SelfContainedEncryptFile(
    const char* filePath,           // 输入文件路径
    const char* outputPath,         // 输出文件路径
    const unsigned char* publicKey, // 公钥
    ProgressCallback progressCallback = nullptr // 进度回调函数
);
```

#### SelfContainedDecryptFile
```cpp
PDUDLL_API int SelfContainedDecryptFile(
    const char* filePath,           // 输入加密文件路径
    const char* outputPath,         // 输出文件路径
    const unsigned char* publicKey, // 公钥
    ProgressCallback progressCallback = nullptr // 进度回调函数
);
```

### 使用流程

#### 1. 直接加密（无需初始化）
```cpp
// 直接加密，自动生成私钥
const char* publicKey = "your_public_key_here";
int result = SelfContainedEncryptFile("input.txt", "output.self", (unsigned char*)publicKey, progressCallback);
```

#### 2. 解密文件
```cpp
// 解密文件（从文件中读取私钥）
result = SelfContainedDecryptFile("output.self", "decrypted.txt", (unsigned char*)publicKey, progressCallback);
```

### 文件格式结构

```
[魔数头: "SELFV1.0"] (8字节)
[组合密钥长度] (4字节)
[公钥哈希值] (4字节)
[私钥长度] (4字节)
[私钥数据] (256字节)
[私钥哈希值] (4字节)
[加密数据] (变长)
[CRC32校验和] (4字节)
```

---

## 技术实现细节

### 加密算法

#### 1. 密钥组合算法
```cpp
// 交错组合私钥和公钥
for (int i = 0; i < totalLen; i++) {
    if (i % 2 == 0) {
        combinedKey[i] = privateKey[i / 2 % privateKeyLength];
    } else {
        combinedKey[i] = publicKey[i / 2 % pubKeyLen];
    }
    // 应用位运算增强混合效果
    combinedKey[i] ^= (unsigned char)(i * 7 + 13);
}
```

#### 2. 双层XOR + 半字节交换加密
```cpp
// 加密过程
unsigned char a1 = originalByte;                                    // 原始字节
unsigned char a2 = a1 ^ keyByte;                                    // 第一次XOR
unsigned char a3 = ((a2 & 0x0F) << 4) | ((a2 & 0xF0) >> 4);       // 半字节交换
unsigned char a4 = a3 ^ keyByte;                                    // 第二次XOR
// a4 为最终加密结果
```

#### 3. 解密过程（自逆操作）
```cpp
// 解密过程（与加密相同，因为XOR和半字节交换都是自逆操作）
unsigned char a1 = encryptedByte;                                   // 加密字节
unsigned char a2 = a1 ^ keyByte;                                    // 第一次XOR
unsigned char a3 = ((a2 & 0x0F) << 4) | ((a2 & 0xF0) >> 4);       // 半字节交换
unsigned char a4 = a3 ^ keyByte;                                    // 第二次XOR
// a4 为最终解密结果
```

### 完整性验证

#### 1. CRC32校验和
```cpp
// 使用标准CRC32算法计算校验和
unsigned int checksum = CalculateCRC32(combinedKey, combinedKeyLength);
```

#### 2. 公钥哈希验证
```cpp
// 计算公钥哈希值用于完整性验证
unsigned int publicKeyHash = CalculatePublicKeyHash(publicKey);
```

#### 3. 私钥哈希验证（自包含式）
```cpp
// 计算私钥哈希值用于完整性验证
unsigned int privateKeyHash = CalculatePrivateKeyHash(privateKey, privateKeyLength);
```

---

## API接口说明

### 进度回调函数
```cpp
typedef void (*ProgressCallback)(const char* filePath, double progress);
```
- **filePath**: 当前处理的文件路径
- **progress**: 进度值（0.0 到 1.0，1.0表示100%完成）

### 返回值说明
- **0**: 成功
- **-1**: 文件打开失败
- **-2**: 内存分配失败
- **-3**: 加密操作失败
- **-4**: 解密操作失败
- **-5**: 无效文件头
- **-6**: 线程创建失败
- **-7**: 无效参数
- **-8**: 私钥未设置

---

## 使用示例

### C++示例代码

#### 双密钥系统示例
```cpp
#include "encode.h"

// 进度回调函数
void ProgressCallback(const char* filePath, double progress) {
    printf("处理文件: %s, 进度: %.2f%%\n", filePath, progress * 100);
}

int main() {
    // 1. 初始化私钥
    int result = InitStreamFile("my_secret_private_key_12345");
    if (result != 0) {
        printf("私钥初始化失败: %d\n", result);
        return -1;
    }
    
    // 2. 加密文件
    const char* publicKey = "my_public_key_67890";
    result = StreamEncryptFile("document.txt", "document.enc", 
                              (unsigned char*)publicKey, ProgressCallback);
    if (result != 0) {
        printf("加密失败: %d\n", result);
        return -1;
    }
    
    // 3. 解密文件
    result = StreamDecryptFile("document.enc", "document_decrypted.txt", 
                              (unsigned char*)publicKey, ProgressCallback);
    if (result != 0) {
        printf("解密失败: %d\n", result);
        return -1;
    }
    
    // 4. 清理私钥
    ClearPrivateKey();
    
    return 0;
}
```

#### 自包含式系统示例
```cpp
#include "encode.h"

void ProgressCallback(const char* filePath, double progress) {
    printf("处理文件: %s, 进度: %.2f%%\n", filePath, progress * 100);
}

int main() {
    // 1. 直接加密（无需初始化）
    const char* publicKey = "my_public_key_67890";
    int result = SelfContainedEncryptFile("document.txt", "document.self", 
                                         (unsigned char*)publicKey, ProgressCallback);
    if (result != 0) {
        printf("加密失败: %d\n", result);
        return -1;
    }
    
    // 2. 解密文件
    result = SelfContainedDecryptFile("document.self", "document_decrypted.txt", 
                                     (unsigned char*)publicKey, ProgressCallback);
    if (result != 0) {
        printf("解密失败: %d\n", result);
        return -1;
    }
    
    return 0;
}
```

### C#示例代码

#### P/Invoke调用示例
```csharp
using System;
using System.Runtime.InteropServices;

public class EncryptionWrapper
{
    // 进度回调委托
    public delegate void ProgressCallback(string filePath, double progress);
    
    // 导入DLL函数
    [DllImport("ExportLib.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int InitStreamFile(string privateKey);
    
    [DllImport("ExportLib.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int StreamEncryptFile(string filePath, string outputPath, 
                                              byte[] publicKey, ProgressCallback progressCallback);
    
    [DllImport("ExportLib.dll", CallingConvention = CallingConvention.Cdecl)]
    public static extern int SelfContainedEncryptFile(string filePath, string outputPath, 
                                                     byte[] publicKey, ProgressCallback progressCallback);
    
    // 使用示例
    public static void EncryptFileExample()
    {
        // 进度回调
        ProgressCallback callback = (filePath, progress) => {
            Console.WriteLine($"处理文件: {filePath}, 进度: {progress:P}");
        };
        
        // 双密钥系统
        int result = InitStreamFile("my_private_key");
        if (result == 0)
        {
            byte[] publicKey = System.Text.Encoding.UTF8.GetBytes("my_public_key");
            result = StreamEncryptFile("input.txt", "output.enc", publicKey, callback);
        }
        
        // 自包含式系统
        byte[] publicKey2 = System.Text.Encoding.UTF8.GetBytes("my_public_key");
        result = SelfContainedEncryptFile("input.txt", "output.self", publicKey2, callback);
    }
}
```

---

## 安全特性

### 1. 密钥管理
- **私钥安全存储**: 使用SecureZeroMemory安全清理内存
- **密钥组合**: 私钥和公钥交错组合，增强安全性
- **哈希验证**: 多重哈希验证确保密钥完整性

### 2. 加密强度
- **2048位私钥**: 自包含式系统使用2048位随机私钥
- **双重加密**: XOR + 半字节交换双重加密
- **位置相关**: 密钥使用与数据位置相关，增强随机性

### 3. 完整性保护
- **CRC32校验**: 使用CRC32算法验证数据完整性
- **多重验证**: 文件头、密钥长度、哈希值多重验证
- **早期检测**: 在解密开始前验证文件完整性

### 4. 内存安全
- **安全清理**: 使用SecureZeroMemory清理敏感数据
- **内存管理**: 严格的内存分配和释放管理
- **错误处理**: 完善的错误处理和资源清理

---

## 性能优化

### 1. 大缓冲区处理
```cpp
const size_t STREAM_BUFFER_SIZE = 4 * 1024 * 1024;  // 4MB大缓冲区
```

### 2. 流式处理
- **内存效率**: 支持大文件处理，无需将整个文件加载到内存
- **实时进度**: 实时进度回调，支持用户界面更新
- **并行处理**: 预留多线程处理接口

### 3. 优化策略
- **批量处理**: 4MB大块处理，减少函数调用开销
- **直接I/O**: 直接文件I/O操作，避免额外缓冲
- **早期验证**: 在开始解密前验证文件完整性

---

## 错误处理

### 1. 错误码定义
```cpp
#define SUCCESS 0                          // 执行成功
#define ERR_FILE_OPEN_FAILED -1           // 文件打开失败
#define ERR_MEMORY_ALLOCATION_FAILED -2   // 内存分配失败
#define ERR_ENCRYPTION_FAILED -3          // 加密操作失败
#define ERR_DECRYPTION_FAILED -4          // 解密操作失败
#define ERR_INVALID_HEADER -5             // 无效文件头
#define ERR_THREAD_CREATION_FAILED -6     // 线程创建失败
#define ERR_INVALID_PARAMETER -7          // 无效参数
#define ERR_PRIVATE_KEY_NOT_SET -8        // 私钥未设置
```

### 2. 错误处理策略
- **资源清理**: 错误发生时自动清理已分配的资源
- **文件清理**: 解密失败时删除不完整的输出文件
- **内存安全**: 使用SecureZeroMemory清理敏感数据

### 3. 错误恢复
```cpp
// 错误处理示例
if (result != SUCCESS) {
    // 清理资源
    if (outputFile) {
        fclose(outputFile);
        remove(outputPath);  // 删除不完整的文件
    }
    if (combinedKey) {
        SecureZeroMemory(combinedKey, combinedKeyLength);
        free(combinedKey);
    }
    return result;
}
```

---

## 最佳实践

### 1. 密钥管理
- **私钥安全**: 妥善保管私钥，避免泄露
- **公钥分发**: 安全分发公钥给授权用户
- **定期更换**: 定期更换密钥对，提高安全性

### 2. 文件处理
- **路径验证**: 验证文件路径的有效性
- **权限检查**: 确保有足够的文件读写权限
- **磁盘空间**: 确保有足够的磁盘空间存储加密文件

### 3. 错误处理
- **返回值检查**: 始终检查函数返回值
- **资源清理**: 确保在错误情况下正确清理资源
- **用户反馈**: 向用户提供清晰的错误信息

### 4. 性能考虑
- **大文件处理**: 对于大文件，使用进度回调提供用户反馈
- **批量处理**: 批量处理多个文件时，考虑内存使用
- **并发处理**: 避免同时处理同一个文件

### 5. 安全建议
- **密钥长度**: 使用足够长度的密钥
- **算法选择**: 根据安全需求选择合适的加密方案
- **完整性验证**: 始终验证加密文件的完整性

---

## 总结

本加密系统提供了两种灵活的文件加密方案：

1. **双密钥流式加密系统**: 适合需要重复使用私钥的场景，提供高效的批量加密能力
2. **自包含式加密系统**: 适合单次加密场景，简化了密钥管理

两种方案都采用了先进的加密算法和完整性验证机制，确保数据的安全性和可靠性。通过合理的API设计和错误处理，为开发者提供了易用且安全的文件加密解决方案。

---

## 附录

### A. 常量定义
```cpp
#define BUFFER_SIZE 4096                   // 标准缓冲区大小
#define MAGIC_HEADER "ENCV1.0"             // 加密文件魔数头标识
#define MAGIC_HEADER_SIZE 7                // 魔数头大小
#define CHUNK_SIZE 1024                    // 数据块大小
#define MAX_THREADS 4                      // 最大线程数量
#define DEFAULT_KEY_LENGTH 256             // 默认最大密钥长度
```

### B. 文件格式对比

| 特性 | 双密钥系统 | 自包含式系统 |
|------|------------|--------------|
| 私钥管理 | 需要预先设置 | 自动生成并嵌入 |
| 文件大小 | 较小 | 较大（包含私钥） |
| 使用复杂度 | 中等 | 简单 |
| 适用场景 | 批量加密 | 单次加密 |
| 私钥重用 | 支持 | 不支持 |

### C. 性能基准
- **加密速度**: 约50-100MB/s（取决于硬件配置）
- **内存使用**: 4MB缓冲区 + 密钥数据
- **CPU使用**: 单线程，CPU密集型操作
- **磁盘I/O**: 顺序读写，适合SSD优化 